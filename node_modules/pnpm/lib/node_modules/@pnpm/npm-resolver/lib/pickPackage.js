"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = require("@pnpm/error");
const logger_1 = require("@pnpm/logger");
const getRegistryName = require("encode-registry");
const loadJsonFile = require("load-json-file");
const p_limit_1 = require("p-limit");
const path = require("path");
const writeJsonFile = require("write-json-file");
const pickPackageFromMeta_1 = require("./pickPackageFromMeta");
const toRaw_1 = require("./toRaw");
/**
 * prevents simultaneous operations on the meta.json
 * otherwise it would cause EPERM exceptions
 */
const metafileOperationLimits = {};
exports.default = async (ctx, spec, opts) => {
    var _a;
    opts = opts || {};
    validatePackageName(spec.name);
    const cachedMeta = ctx.metaCache.get(spec.name);
    if (cachedMeta) {
        return {
            meta: cachedMeta,
            pickedPackage: pickPackageFromMeta_1.default(spec, opts.preferredVersionSelectors, cachedMeta),
        };
    }
    const registryName = getRegistryName(opts.registry);
    const pkgMirror = path.join(ctx.storeDir, registryName, spec.name);
    const limit = metafileOperationLimits[pkgMirror] = metafileOperationLimits[pkgMirror] || p_limit_1.default(1);
    let metaCachedInStore;
    if (ctx.offline || ctx.preferOffline) {
        metaCachedInStore = await limit(() => loadMeta(pkgMirror, ctx.metaFileName));
        if (ctx.offline) {
            if (metaCachedInStore)
                return {
                    meta: metaCachedInStore,
                    pickedPackage: pickPackageFromMeta_1.default(spec, opts.preferredVersionSelectors, metaCachedInStore),
                };
            throw new error_1.default('NO_OFFLINE_META', `Failed to resolve ${toRaw_1.default(spec)} in package mirror ${pkgMirror}`);
        }
        if (metaCachedInStore) {
            const pickedPackage = pickPackageFromMeta_1.default(spec, opts.preferredVersionSelectors, metaCachedInStore);
            if (pickedPackage) {
                return {
                    meta: metaCachedInStore,
                    pickedPackage,
                };
            }
        }
    }
    if (spec.type === 'version') {
        metaCachedInStore = metaCachedInStore || await limit(() => loadMeta(pkgMirror, ctx.metaFileName));
        // use the cached meta only if it has the required package version
        // otherwise it is probably out of date
        if ((_a = metaCachedInStore === null || metaCachedInStore === void 0 ? void 0 : metaCachedInStore.versions) === null || _a === void 0 ? void 0 : _a[spec.fetchSpec]) {
            return {
                meta: metaCachedInStore,
                pickedPackage: metaCachedInStore.versions[spec.fetchSpec],
            };
        }
    }
    try {
        const meta = await ctx.fetch(spec.name, opts.registry, opts.authHeaderValue);
        meta.cachedAt = Date.now();
        // only save meta to cache, when it is fresh
        ctx.metaCache.set(spec.name, meta);
        if (!opts.dryRun) {
            // tslint:disable-next-line:no-floating-promises
            limit(() => saveMeta(pkgMirror, meta, ctx.metaFileName));
        }
        return {
            meta,
            pickedPackage: pickPackageFromMeta_1.default(spec, opts.preferredVersionSelectors, meta),
        };
    }
    catch (err) {
        const meta = await loadMeta(pkgMirror, ctx.metaFileName); // TODO: add test for this usecase
        if (!meta)
            throw err;
        logger_1.default.error(err, err);
        logger_1.default.debug({ message: `Using cached meta from ${pkgMirror}` });
        return {
            meta,
            pickedPackage: pickPackageFromMeta_1.default(spec, opts.preferredVersionSelectors, meta),
        };
    }
};
async function loadMeta(pkgMirror, metaFileName) {
    try {
        return await loadJsonFile(path.join(pkgMirror, metaFileName));
    }
    catch (err) {
        return null;
    }
}
function saveMeta(pkgMirror, meta, metaFileName) {
    return writeJsonFile(path.join(pkgMirror, metaFileName), meta);
}
function validatePackageName(pkgName) {
    if (pkgName.includes('/') && pkgName[0] !== '@') {
        throw new error_1.default('INVALID_PACKAGE_NAME', `Package name ${pkgName} is invalid, it should have a @scope`);
    }
}
//# sourceMappingURL=pickPackage.js.map